From e8a9fec2cfd9862a32d4d74451765d865c4c1f89 Mon Sep 17 00:00:00 2001
From: Tomas Hozza <thozza@redhat.com>
Date: Fri, 14 Dec 2012 13:49:17 +0100
Subject: [PATCH] Set SO_BINDTODEVICE when creating sockets

Set socket option SO_BINDTODEVICE when creating
socket for bound listeners (bind-interfaces).

Signed-off-by: Tomas Hozza <thozza@redhat.com>
---
 man/dnsmasq.8 |  7 +++++++
 src/dnsmasq.c |  6 +++++-
 src/dnsmasq.h |  1 +
 src/network.c | 18 +++++++++++++++---
 4 files changed, 28 insertions(+), 4 deletions(-)

diff --git a/man/dnsmasq.8 b/man/dnsmasq.8
index c02c90b..176379d 100644
--- a/man/dnsmasq.8
+++ b/man/dnsmasq.8
@@ -196,6 +196,13 @@ listening on. About the only time when this is useful is when
 running another nameserver (or another instance of dnsmasq) on the
 same machine. Setting this option also enables multiple instances of
 dnsmasq which provide DHCP service to run in the same machine.
+
+This option has been patched to always use SO_BINDTODEVICE socket option
+when binding to interfaces. As consequence, dnsmasq
+.B WILL NOT ANSWER
+to any DNS Queries that come to the socket with the correct destination IP
+address, but originally on different interface. This behavior differs from
+the original dnsmasq upstream version and is used for security reasons.
 .TP
 .B \-y, --localise-queries
 Return answers to DNS queries from /etc/hosts which depend on the interface over which the query was
diff --git a/src/dnsmasq.c b/src/dnsmasq.c
index 7036763..1088c14 100644
--- a/src/dnsmasq.c
+++ b/src/dnsmasq.c
@@ -48,7 +48,11 @@ static char *compile_opts =
 #ifndef HAVE_TFTP
 "no-"
 #endif
-"TFTP";
+"TFTP"
+#ifdef SO_BINDTODEVICE
+" \"--bind-interfaces with SO_BINDTODEVICE\""
+#endif
+;
 
 static volatile pid_t pid = 0;
 static volatile int pipewrite;
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index 9251af8..0f05901 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -337,6 +337,7 @@ struct irec {
   union mysockaddr addr;
   struct in_addr netmask; /* only valid for IPv4 */
   int dhcp_ok;
+  char *name;
   struct irec *next;
 };
 
diff --git a/src/network.c b/src/network.c
index 339fd12..342df2c 100644
--- a/src/network.c
+++ b/src/network.c
@@ -188,9 +188,14 @@ static int iface_allowed(struct irec **irecp, int if_index,
       iface->addr = *addr;
       iface->netmask = netmask;
       iface->dhcp_ok = dhcp_ok;
-      iface->next = *irecp;
-      *irecp = iface;
-      return 1;
+      if ((iface->name = whine_malloc(strlen(ifr.ifr_name)+1)))
+        {
+          strcpy(iface->name, ifr.ifr_name);
+          iface->next = *irecp;
+          *irecp = iface;
+          return 1;
+        }
+      free(iface);
     }
   
   errno = ENOMEM; 
@@ -404,6 +409,10 @@ struct listener *create_bound_listeners(void)
 	{
 	  if ((new->tcpfd = socket(iface->addr.sa.sa_family, SOCK_STREAM, 0)) == -1 ||
 	      (new->fd = socket(iface->addr.sa.sa_family, SOCK_DGRAM, 0)) == -1 ||
+#ifdef SO_BINDTODEVICE
+          setsockopt(new->fd, SOL_SOCKET, SO_BINDTODEVICE, iface->name, strlen(iface->name)) == -1 ||
+          setsockopt(new->tcpfd, SOL_SOCKET, SO_BINDTODEVICE, iface->name, strlen(iface->name)) == -1 ||
+#endif
 	      setsockopt(new->fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1 ||
 	      setsockopt(new->tcpfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1 ||
 	      !fix_fd(new->tcpfd) ||
@@ -455,6 +464,9 @@ struct listener *create_bound_listeners(void)
 	  short save = iface->addr.in.sin_port;
 	  iface->addr.in.sin_port = htons(TFTP_PORT);
 	  if ((new->tftpfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1 ||
+#ifdef SO_BINDTODEVICE
+          setsockopt(new->tftpfd, SOL_SOCKET, SO_BINDTODEVICE, iface->name, strlen(iface->name)) == -1 ||
+#endif
 	      setsockopt(new->tftpfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1 ||
 	      !fix_fd(new->tftpfd) ||
 	      bind(new->tftpfd, &iface->addr.sa, sa_len(&iface->addr)) == -1)
-- 
1.7.11.7

